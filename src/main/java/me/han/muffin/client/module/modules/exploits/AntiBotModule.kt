package me.han.muffin.client.module.modules.exploits

import me.han.muffin.client.core.Globals
import me.han.muffin.client.event.EventStageable
import me.han.muffin.client.event.events.client.AttackEvent
import me.han.muffin.client.event.events.client.TickEvent
import me.han.muffin.client.event.events.network.PacketEvent
import me.han.muffin.client.event.events.network.ServerEvent
import me.han.muffin.client.module.Module
import me.han.muffin.client.utils.math.rotation.Vec2d
import me.han.muffin.client.value.EnumValue
import me.han.muffin.client.value.NumberValue
import me.han.muffin.client.value.Value
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.network.play.client.CPacketUseEntity
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener
import kotlin.math.abs

object AntiBotModule: Module("AntiBot", Category.EXPLOITS, "For playing hypixel.") {
    private val server = EnumValue(Servers.None, "Server")
    private val tabList = Value(true, "Tab")
    private val ping = Value(true,"Ping")
    private val hp = Value(true,"Health")
    private val head = Value(true,"Head")
    private val sleeping = Value(false, "Sleeping")
    private val ticksExisted = NumberValue(200, 0, 500, 5, "TicksExisted")

    private val botSet = HashSet<EntityPlayer>()

    private enum class Servers {
        None, Hypixel, Mineplex
    }

    init {
        addSettings(tabList, ping, hp, head, sleeping, ticksExisted)
    }

    @Listener
    private fun onDisconnect(event: ServerEvent.Disconnect) {
        if (event.state != EventStageable.EventStage.PRE) return
        botSet.clear()
    }

    @Listener
    private fun onAttack(event: AttackEvent) {
        if (isEnabled && botSet.contains(event.entity)) event.cancel()
    }

    @Listener
    private fun onPacketSent(event: PacketEvent.Send) {
        if (event.stage != EventStageable.EventStage.PRE) return

        if (event.packet is CPacketUseEntity && event.packet.action == CPacketUseEntity.Action.ATTACK) {
            val attackedEntity = event.packet.getEntityFromWorld(Globals.mc.world) ?: return
            if (isEnabled && botSet.contains(attackedEntity)) event.cancel()
        }

    }

    @Listener
    private fun onTicking(event: TickEvent) {
        if (fullNullCheck()) return

        val cacheSet = HashSet<EntityPlayer>()
        for (entity in Globals.mc.world.loadedEntityList) {
            if (entity !is EntityPlayer || entity == Globals.mc.player || !isBot(entity)) continue
            cacheSet.add(entity)
        }

        botSet.removeIf { !cacheSet.contains(it) }
        botSet.addAll(cacheSet)
    }

    fun isBot(entity: EntityPlayer) =
        entity.name == Globals.mc.player.name
                || entity.name == "popbob"
                || tabList.value && Globals.mc.connection?.getPlayerInfo(entity.name) == null
                || ping.value && Globals.mc.connection?.getPlayerInfo(entity.name)?.responseTime ?: -1 <= 0
                || hp.value && entity.health !in 0f..20f
                || sleeping.value && entity.isPlayerSleeping && !entity.onGround
                || head.value && hoverCheck(entity)
                || entity.ticksExisted < ticksExisted.value

    fun isHypixelBot(entity: EntityPlayer) =
        Globals.mc.connection?.getPlayerInfo(entity.name) == null &&
                !entity.displayName.formattedText.toLowerCase().contains("[npc") &&
                entity.displayName.formattedText.startsWith("\u00a7")

    private fun hoverCheck(entity: EntityPlayer): Boolean {
        val distXZ = Vec2d(entity.posX, entity.posZ).minus(Globals.mc.player.posX, Globals.mc.player.posZ).lengthSquared()
        return distXZ < 16 && entity.posY - Globals.mc.player.posY > 2.0 && abs(entity.posY - entity.prevPosY) < 0.1
    }

}