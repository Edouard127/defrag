package me.han.muffin.client.module.modules.exploits

import me.han.muffin.client.core.Globals
import me.han.muffin.client.event.EventStageable
import me.han.muffin.client.event.events.client.KeyPressedEvent
import me.han.muffin.client.event.events.client.MouseEvent
import me.han.muffin.client.event.events.gui.GuiScreenEvent
import me.han.muffin.client.event.events.network.PacketEvent
import me.han.muffin.client.module.Module
import me.han.muffin.client.utils.client.BindUtils
import me.han.muffin.client.utils.extensions.mixin.netty.windowId
import me.han.muffin.client.value.BindValue
import net.minecraft.client.gui.inventory.GuiContainer
import net.minecraft.client.gui.inventory.GuiInventory
import net.minecraft.network.play.client.CPacketCloseWindow
import net.minecraft.network.play.server.SPacketCloseWindow
import org.lwjgl.input.Keyboard
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener

internal object ChestBackpackModule: Module("ChestBackPack", Category.EXPLOITS, "Close container screen and open it by anytime.") {
    private val bind = BindValue(Keyboard.KEY_NONE, "ChestOpen")

    private var container: GuiContainer? = null

    init {
        addSettings(bind)
    }

    override fun onDisable() {
        if (container != null) Globals.mc.player.connection.sendPacket(CPacketCloseWindow(container!!.inventorySlots.windowId))
        container = null
    }

    @Listener
    private fun onGuiDisplayed(event: GuiScreenEvent.Displayed) {
        if (event.screen is GuiContainer && event.screen !is GuiInventory) container = event.screen as GuiContainer
    }

    @Listener
    private fun onMouseInput(event: MouseEvent) {
        if (fullNullCheck()) return
        if (BindUtils.checkIsClickedToggle(bind.value)) if (container != null) Globals.mc.displayGuiScreen(container)
    }

    @Listener
    private fun onKeyPressed(event: KeyPressedEvent) {
        if (fullNullCheck()) return
        if (BindUtils.checkIsClickedToggle(bind.value)) if (container != null) Globals.mc.displayGuiScreen(container)
    }

    @Listener
    private fun onPacketSend(event: PacketEvent.Send) {
        if (event.stage != EventStageable.EventStage.PRE || fullNullCheck()) return
        if (event.packet is CPacketCloseWindow) event.cancel()
    }

    @Listener
    private fun onPacketReceive(event: PacketEvent.Receive) {
        if (event.stage != EventStageable.EventStage.PRE || fullNullCheck()) return

        if (event.packet is SPacketCloseWindow && container != null) {
            if (container!!.inventorySlots != null && event.packet.windowId == container!!.inventorySlots.windowId)
                container = null
        }
    }

}