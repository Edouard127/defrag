package me.han.muffin.client.module.modules.exploits

import me.han.muffin.client.core.Globals
import me.han.muffin.client.event.EventStageable
import me.han.muffin.client.event.events.client.MotionUpdateEvent
import me.han.muffin.client.event.events.network.PacketEvent
import me.han.muffin.client.manager.managers.ChatManager
import me.han.muffin.client.module.Module
import me.han.muffin.client.utils.ChatIDs
import me.han.muffin.client.utils.InfoUtils
import me.han.muffin.client.utils.extensions.mc.entity.isAlive
import me.han.muffin.client.utils.extensions.mc.utils.toStringFormat
import me.han.muffin.client.utils.math.VectorUtils.toVec3d
import me.han.muffin.client.utils.math.rotation.RotationUtils
import me.han.muffin.client.value.Value
import net.minecraft.client.entity.EntityPlayerSP
import net.minecraft.entity.Entity
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.SoundEvents
import net.minecraft.network.play.server.SPacketEffect
import net.minecraft.network.play.server.SPacketEntityTeleport
import net.minecraft.network.play.server.SPacketSoundEffect
import net.minecraft.network.play.server.SPacketSpawnMob
import net.minecraft.util.SoundCategory
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Vec3d
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener
import kotlin.math.abs
import kotlin.math.roundToInt
import kotlin.math.sqrt

object CoordExploitModule: Module("CoordExploit", Category.EXPLOITS, "Get some specified coords by exploiting.") {

    private val teleportDetection = Value(true, "Teleport")
    private val thunder = Value(true, "Thunder")
    private val endPortal = Value(true, "EndPortal")
    private val wither = Value(true, "Wither")
    private val endDragon = Value(true, "EndDragon")
    private val slimes = Value(false, "Slimes")

    private val knownPlayers = HashMap<Entity, Vec3d>()
    private val tpdPlayers = HashMap<String, Vec3d>()
    private var numTicks = 0
    private var numForgetTicks = 0

    init {
        addSettings(teleportDetection, thunder, endPortal, wither, endDragon, slimes)
    }

    @Listener
    private fun onPacketReceive(event: PacketEvent.Receive) {
        if (event.stage != EventStageable.EventStage.PRE || fullNullCheck()) return

        if (slimes.value && event.packet is SPacketSpawnMob) {
            if (event.packet.entityType == 55 && event.packet.y <= 40 && !Globals.mc.world.getBiome(Globals.mc.player.position).biomeName.toLowerCase().contains("swamp")) {
                val pos = BlockPos(event.packet.x, event.packet.y, event.packet.z)
                ChatManager.sendDeleteMessage("Slime Spawned in chunk X:" + Globals.mc.world.getChunk(pos).x + " Z:" + Globals.mc.world.getChunk(pos).z, "Slime", ChatIDs.COORDS_EXPLOIT)
            }
        }

        if (thunder.value && event.packet is SPacketSoundEffect) {
            if (event.packet.category == SoundCategory.WEATHER && event.packet.sound == SoundEvents.ENTITY_LIGHTNING_THUNDER) {
                val rotationPlaceholder = getRotationPlaceholder(Vec3d(event.packet.x, event.packet.y, event.packet.z))

                val yaw = rotationPlaceholder.first
                val direction = rotationPlaceholder.second
                val toward = rotationPlaceholder.third

                val placeholder = "Lightning spawned X: ${Globals.mc.player.posX} Z: ${Globals.mc.player.posZ} Angle: $yaw Direction: $direction ($toward)"
                ChatManager.sendDeleteMessage(placeholder, "Lightning", ChatIDs.COORDS_EXPLOIT)
            }
        }

        if (event.packet is SPacketEffect) {
            when (event.packet.soundType) {
                1038 -> {
                    if (endPortal.value) {
                        val rotationPlaceholder = getRotationPlaceholder(event.packet.soundPos.toVec3d())
                        val yaw = rotationPlaceholder.first
                        val direction = rotationPlaceholder.second
                        val toward = rotationPlaceholder.third

                        val placeholder = "End Portal activated at X: ${event.packet.soundPos.x} Y: ${event.packet.soundPos.y} Z: ${event.packet.soundPos.z} Angle: $yaw Direction: $direction ($toward)"
                        ChatManager.sendDeleteMessage(placeholder, "End", ChatIDs.COORDS_EXPLOIT)
                    }
                }
                1023 -> {
                    if (wither.value) {
                        val rotationPlaceholder = getRotationPlaceholder(event.packet.soundPos.toVec3d())
                        val yaw = rotationPlaceholder.first
                        val direction = rotationPlaceholder.second
                        val toward = rotationPlaceholder.third

                        val placeholder = "Wither spawned at X: ${Globals.mc.player.posX} Z: ${Globals.mc.player.posZ} Angle: $yaw Direction: $direction ($toward)"
                        ChatManager.sendDeleteMessage(placeholder, "Wither", ChatIDs.COORDS_EXPLOIT)
                    }
                }
                1028 -> {
                    if (endDragon.value) {
                        val rotationPlaceholder = getRotationPlaceholder(event.packet.soundPos.toVec3d())
                        val yaw = rotationPlaceholder.first
                        val direction = rotationPlaceholder.second
                        val toward = rotationPlaceholder.third

                        val placeholder = "Ender Dragon killed at X: ${Globals.mc.player.posX} Z: ${Globals.mc.player.posZ} Angle: $yaw Direction: $direction ($toward)"
                        ChatManager.sendDeleteMessage(placeholder, "Ender", ChatIDs.COORDS_EXPLOIT)
                    }
                }
            }
        }


        if (teleportDetection.value && event.packet is SPacketEntityTeleport) {
            val entityByID = Globals.mc.world?.getEntityByID(event.packet.entityId) ?: return
            if (entityByID is EntityPlayer && entityByID !is EntityPlayerSP) {
                val x = abs(entityByID.posX) - abs(event.packet.x)
                val y = abs(entityByID.posY) - abs(event.packet.y)
                val z = abs(entityByID.posZ) - abs(event.packet.z)
                if (sqrt(x * x + y * y + z * z) > 50) {
                    ChatManager.sendDeleteMessage(entityByID.name + " has tp to X: " + event.packet.x.roundToInt() + ", Y: " + event.packet.y.roundToInt() + ", Z: " + event.packet.z.roundToInt(), entityByID.name, ChatIDs.COORDS_EXPLOIT)
                }
            }
        }

    }

    @Listener
    private fun onMotionUpdate(event: MotionUpdateEvent) {
        if (event.stage != EventStageable.EventStage.PRE) return

        if (teleportDetection.value) {
            if (numTicks >= 50) {
                numTicks = 0

                for (entity in Globals.mc.world.loadedEntityList) {
                    if (entity == null || entity !is EntityPlayer || entity.name == Globals.mc.player.name || !entity.isAlive) continue

                    val playerPos = entity.positionVector

                    if (knownPlayers.containsKey(entity)) {
                        if (abs(knownPlayers[entity]!!.distanceTo(playerPos)) > 50.0 && abs(Globals.mc.player.positionVector.distanceTo(playerPos)) > 100.0 && (!tpdPlayers.containsKey(entity.name) || tpdPlayers[entity.name] != playerPos)) {
                            ChatManager.sendDeleteMessage("Player " + entity.name + " teleported to " + playerPos.toStringFormat(), entity.name, ChatIDs.COORDS_EXPLOIT)
                            knownPlayers.remove(entity)
                            tpdPlayers[entity.name] = playerPos
                        }
                        knownPlayers[entity] = playerPos
                        continue
                    }

                    knownPlayers[entity] = playerPos
                }
            }

            if (numForgetTicks >= 9000000) {
                tpdPlayers.clear()
            }

            ++numTicks
            ++numForgetTicks
        }
    }

    private fun getRotationPlaceholder(vector: Vec3d): Triple<String, String, String> {
        val rotation = RotationUtils.getRotationTo(vector)

        val yaw = rotation.x
        val direction = InfoUtils.getDirection(yaw)

        return Triple(yaw.toString(), direction.displayFacing, direction.displayToward)
    }

}