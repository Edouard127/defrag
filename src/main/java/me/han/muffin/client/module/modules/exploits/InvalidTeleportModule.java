package me.han.muffin.client.module.modules.exploits;

import me.han.muffin.client.core.Globals;
import me.han.muffin.client.event.EventStageable;
import me.han.muffin.client.event.events.client.MotionUpdateEvent;
import me.han.muffin.client.event.events.network.PacketEvent;
import me.han.muffin.client.imixin.netty.packet.client.ICPacketPlayer;
import me.han.muffin.client.module.Module;
import me.han.muffin.client.utils.block.HoleUtils;
import me.han.muffin.client.utils.client.BindUtils;
import me.han.muffin.client.utils.entity.MovementUtils;
import me.han.muffin.client.utils.math.VectorUtils;
import me.han.muffin.client.utils.timer.Timer;
import me.han.muffin.client.value.BindValue;
import me.han.muffin.client.value.EnumValue;
import me.han.muffin.client.value.NumberValue;
import me.han.muffin.client.value.Value;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import org.lwjgl.input.Keyboard;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class InvalidTeleportModule extends Module {
    private final EnumValue<Mode> mode = new EnumValue<>(Mode.Normal, "Mode");
    private final NumberValue<Float> speed = new NumberValue<>(v -> mode.getValue() == Mode.Normal || mode.getValue() == Mode.Zone,0.04F, 0.01F, 2.00F, 0.01F, "NormalSpeed");
    private final Value<Boolean> extraTp = new Value<>(v -> mode.getValue() == Mode.Zone, true, "ExtraTp");
    private final BindValue<Integer> normalBind = new BindValue<>((Integer) Keyboard.KEY_NONE, "NormalTeleport");
    private final NumberValue<Integer> radius = new NumberValue<>(5, 1, 50, 1, "Radius");

    public InvalidTeleportModule() {
        super("InvalidTeleport", Category.EXPLOITS, "Allow you to teleport to a hole.");
        addSettings(mode, speed, normalBind, extraTp, radius);
    }

    private enum Mode {
        Normal, Old, New, Packet, Zone
    }

    private int delay;
    private BlockPos endPos;
    private RayTraceResult rayTraceResult;
    private final Timer timer = new Timer();

    @Override
    public void onDisable() {
        delay = 0;
        endPos = null;
    }

    @Listener
    private void onMotionUpdate(MotionUpdateEvent event) {
        if (event.getStage() != EventStageable.EventStage.PRE)
            return;

        if (Globals.mc.currentScreen == null && delay <= 0) {

            int range = radius.getValue();

            List<BlockPos> blocks = VectorUtils.INSTANCE.getBlockPosInSphere(
                    Globals.mc.player.getPositionEyes(1F), range)
                    .stream()
                    .sorted(Comparator.comparing(pos -> Globals.mc.player.getDistance(pos.getX(), pos.getY(), pos.getZ())))
                    .collect(Collectors.toList());

            for (BlockPos pos : blocks) {

                // block gotta be air
                if (!Globals.mc.world.getBlockState(pos).getBlock().equals(Blocks.AIR)) continue;

                // block 1 above gotta be air
                if (!Globals.mc.world.getBlockState(pos.add(0, 1, 0)).getBlock().equals(Blocks.AIR)) continue;

                // block 2 above gotta be air
                if (!Globals.mc.world.getBlockState(pos.add(0, 2, 0)).getBlock().equals(Blocks.AIR)) continue;

                if (pos.equals(new BlockPos(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ))) continue;

                boolean isSafe = true;

                for (BlockPos offset : HoleUtils.INSTANCE.getSurroundOffset()) {
                    Block block = Globals.mc.world.getBlockState(pos.add(offset)).getBlock();
                    if (block != Blocks.BEDROCK && block != Blocks.OBSIDIAN && block != Blocks.ENDER_CHEST && block != Blocks.ANVIL) {
                        isSafe = false;
                        break;
                    }
                }

                if (isSafe) endPos = pos;

            }

            delay = 6;
        }

        if (delay > 0) --delay;

        if (endPos != null) {

            final double endX = (double) endPos.getX() + 0.5D;
            final double endY = (double) endPos.getY() + 1.0D;
            final double endZ = (double) endPos.getZ() + 0.5D;

            if (mode.getValue() == Mode.Normal && BindUtils.INSTANCE.checkIsClicked(normalBind.getValue())) {
                Globals.mc.player.connection.sendPacket(new CPacketEntityAction(Globals.mc.player, CPacketEntityAction.Action.STOP_SNEAKING));
                Globals.mc.player.setVelocity(0, 0, 0);
                event.cancel();

                Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
                Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
                Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
                Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
                Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
                Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ + 0.5D, true));

                MovementUtils.INSTANCE.forward(speed.getValue());
                Globals.mc.player.connection.sendPacket(new CPacketEntityAction(Globals.mc.player, CPacketEntityAction.Action.STOP_SNEAKING));

                event.cancel();

            }

            if (mode.getValue() == Mode.Zone && BindUtils.INSTANCE.checkIsClicked(normalBind.getValue())) {
                Globals.mc.player.setVelocity(0, 0, 0);
                event.cancel();

                if (extraTp.getValue()) {
                    final double[] startPos = {Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ};
                    teleport(startPos, new BlockPos(endX, endY, endZ));
                }

                for (int i = 0; i < 8; ++i) {
                    Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
                    Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
                    Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
                    Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY + 5D, Globals.mc.player.posZ, true));
                    Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
                    Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX + 0.5D, Globals.mc.player.posY, Globals.mc.player.posZ + 0.5D, true));
                }

                MovementUtils.INSTANCE.forward(speed.getValue());
                event.cancel();
            }

            if ((mode.getValue() == Mode.New || mode.getValue() == Mode.Old) && (Keyboard.isKeyDown(Keyboard.KEY_LMENU) || Keyboard.isKeyDown(Keyboard.KEY_RMENU))) {
                Globals.mc.player.setVelocity(0, 0, 0);
                event.cancel();

                if (mode.getValue() == Mode.New) {
                    if (timer.passed(500)) {
                        timer.reset();
                        event.cancel();

                        final double[] startPos = {Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ};
                        hypixelTeleport(startPos, new BlockPos(endX, endY, endZ));

                        event.cancel();
                    }

                } else if (mode.getValue() == Mode.Old) {
                    event.cancel();

                    final double[] startPos = {Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ};
                    teleport(startPos, new BlockPos(endX, endY, endZ));

                    event.cancel();
                }
            }

        }

    }

    @Listener
    public void onPacketSent(final PacketEvent event) {
        if (event.getStage() != EventStageable.EventStage.PRE)
            return;

        if (mode.getValue() == Mode.Packet) {
            if (event.getPacket() instanceof CPacketPlayer) {
                final CPacketPlayer packetPlayer = (CPacketPlayer) event.getPacket();
                if (endPos == null)
                    return;

                ((ICPacketPlayer) packetPlayer).setX(endPos.getX() + 0.5D);
                ((ICPacketPlayer) packetPlayer).setY(endPos.getY() + 1);
                ((ICPacketPlayer) packetPlayer).setZ(endPos.getZ() + 0.5D);
                Globals.mc.player.setPosition(endPos.getX() + 0.5D, endPos.getY() + 1, endPos.getZ() + 0.5D);

            }
        }
    }

    public void teleport(final double[] startPos, final BlockPos endPos){
        double distx = startPos[0] - endPos.getX()+ 0.5;
        double disty = startPos[1] - endPos.getY();
        double distz = startPos[2] - endPos.getZ()+ 0.5;
        double dist = Math.sqrt(Globals.mc.player.getDistanceSq(endPos));
        double distanceEntreLesPackets = 5;
        double xtp, ytp, ztp = 0;

        if (dist> distanceEntreLesPackets){
            double nbPackets = Math.round(dist / distanceEntreLesPackets + 0.49999999999) - 1;
            xtp = Globals.mc.player.posX;
            ytp = Globals.mc.player.posY;
            ztp = Globals.mc.player.posZ;
            double count = 0;
            for (int i = 1; i < nbPackets;i++){
                double xdi = (endPos.getX() - Globals.mc.player.posX)/( nbPackets);
                xtp += xdi;

                double zdi = (endPos.getZ() - Globals.mc.player.posZ)/( nbPackets);
                ztp += zdi;

                double ydi = (endPos.getY() - Globals.mc.player.posY)/( nbPackets);
                ytp += ydi;
                count ++;
                CPacketPlayer.Position Packet= new CPacketPlayer.Position(xtp, ytp, ztp, true);

                Globals.mc.player.connection.sendPacket(Packet);
            }

            Globals.mc.player.setPosition(endPos.getX() + 0.5, endPos.getY(), endPos.getZ() + 0.5);
        } else {
            final double endX = (double) endPos.getX() + 0.5D;
            final double endY = (double) endPos.getY() + 1.0D;
            final double endZ = (double) endPos.getZ() + 0.5D;

            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY + 5D, Globals.mc.player.posZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX + 0.5D, Globals.mc.player.posY, Globals.mc.player.posZ + 0.5D, true));
            MovementUtils.INSTANCE.forward(speed.getValue());
        }
    }

    public void hypixelTeleport(final double[] startPos, final BlockPos endPos){

        double distx = startPos[0] - endPos.getX()+ 0.5;
        double disty = startPos[1] - endPos.getY();
        double distz = startPos[2] - endPos.getZ()+ 0.5;
        double dist = Math.sqrt(Globals.mc.player.getDistanceSq(endPos));
        double distanceEntreLesPackets = 0.31 + MovementUtils.INSTANCE.getSpeedEffect() / 20;
        double xtp, ytp, ztp = 0;
        if (dist> distanceEntreLesPackets){

            double nbPackets = Math.round(dist / distanceEntreLesPackets + 0.49999999999) - 1;

            xtp = Globals.mc.player.posX;
            ytp = Globals.mc.player.posY;
            ztp = Globals.mc.player.posZ;
            double count = 0;
            for (int i = 1; i < nbPackets; i++){
                double xdi = (endPos.getX() - Globals.mc.player.posX)/( nbPackets);
                xtp += xdi;

                double zdi = (endPos.getZ() - Globals.mc.player.posZ)/( nbPackets);
                ztp += zdi;

                double ydi = (endPos.getY() - Globals.mc.player.posY)/( nbPackets);
                ytp += ydi;
                count ++;

                if (!Globals.mc.world.getBlockState(new BlockPos(xtp, ytp-1, ztp)).isFullCube()){
                    if (count <= 2) {
                        ytp += 2E-8;
                    } else if (count >= 4) {
                        count = 0;
                    }
                }
                CPacketPlayer.Position Packet= new CPacketPlayer.Position(xtp, ytp, ztp, false);
                Globals.mc.player.connection.sendPacket(Packet);
            }

            Globals.mc.player.setPosition(endPos.getX() + 0.5, endPos.getY(), endPos.getZ() + 0.5);

        } else {
            final double endX = (double) endPos.getX() + 0.5D;
            final double endY = (double) endPos.getY() + 1.0D;
            final double endZ = (double) endPos.getZ() + 0.5D;

            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY + 5D, Globals.mc.player.posZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(endX, endY, endZ, true));
            Globals.mc.player.connection.sendPacket(new CPacketPlayer.Position(Globals.mc.player.posX + 0.5D, Globals.mc.player.posY, Globals.mc.player.posZ + 0.5D, true));
            MovementUtils.INSTANCE.forward(speed.getValue());
        }
    }

}