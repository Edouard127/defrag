package me.han.muffin.client.module.modules.exploits

import io.netty.util.internal.ConcurrentSet
import me.han.muffin.client.core.Globals
import me.han.muffin.client.event.EventStageable
import me.han.muffin.client.event.events.client.MotionUpdateEvent
import me.han.muffin.client.event.events.client.MoveEvent
import me.han.muffin.client.event.events.client.TickEvent
import me.han.muffin.client.event.events.entity.player.PlayerApplyCollisionEvent
import me.han.muffin.client.event.events.network.PacketEvent
import me.han.muffin.client.event.events.render.IsEntityInsideOpaqueBlockEvent
import me.han.muffin.client.event.events.render.overlay.RenderOverlayEvent
import me.han.muffin.client.event.events.world.SetOpaqueCubeEvent
import me.han.muffin.client.event.events.world.WorldClientInitEvent
import me.han.muffin.client.event.events.world.WorldEvent
import me.han.muffin.client.manager.managers.LocalMotionManager.addMotion
import me.han.muffin.client.module.Module
import me.han.muffin.client.utils.entity.EntityUtil
import me.han.muffin.client.utils.entity.MovementUtils
import me.han.muffin.client.utils.extensions.kotlin.synchronized
import me.han.muffin.client.utils.extensions.mc.entity.isAlive
import me.han.muffin.client.utils.extensions.mixin.netty.rotationPitch
import me.han.muffin.client.utils.extensions.mixin.netty.rotationYaw
import me.han.muffin.client.utils.math.RandomUtils
import me.han.muffin.client.value.EnumValue
import me.han.muffin.client.value.NumberValue
import me.han.muffin.client.value.Value
import net.minecraft.client.gui.GuiDownloadTerrain
import net.minecraft.network.play.client.CPacketConfirmTeleport
import net.minecraft.network.play.client.CPacketPlayer
import net.minecraft.network.play.server.SPacketCloseWindow
import net.minecraft.network.play.server.SPacketPlayerPosLook
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Vec3d
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener
import java.util.concurrent.TimeUnit
import kotlin.math.cos
import kotlin.math.sin

/**
 * @author han
 * Created by han on 27/6/2020
 * Updated by han on 19/10/2020
 */
internal object PacketFlyModule: Module("PacketFly", Category.EXPLOITS, "NCP flying using packet exploit.") {

    private val mode = EnumValue(Mode.Fast, "Mode")
    private val factor = NumberValue(2.0, 1.0, 10.0, 0.1, "Factor")
    private val reduction = NumberValue(2.5, 0.0, 1.0, 0.01, "Reduction")
    private val phaseType = EnumValue(PhaseType.Full, "Phase")
    private val type = EnumValue(Types.Limit, "Type")
    private val antiKick = Value(true, "AntiKick")
    private val betterResponse = Value(false, "BetterResponse")
    private val invalid = Value(true, "Invalid")
    private val limitMode = EnumValue(LimitMode.Off, "LimitMode")
    private val old = Value(false, "Old")
    private val fastCollision = Value(true, "FastCollide")
    private val rotation = Value(true, "Rotation")
    private val instantPhase = Value(true, "Instant")
    private val conceal = Value(false, "Conceal")
    private val airStrict = Value(true, "AirStrict")
    private val constantly = Value(false, "Constantly")
    private val test = Value(false, "test")
    private val strictPhase = Value(false, "StrictPhase")

    private var tickCounter = 0
    private var limitTickCounter = 0
    private var constantTickCounter = 0

    private var teleportId = 0

    private val teleportMap = hashMapOf<Int, IDTime>().synchronized()
    private val playerPackets = ConcurrentSet<CPacketPlayer>()

    private var isGoingUp = false

    private var canClip = false
    private var shouldConceal = false
    private var sentCount = 0

    private var ticksInAir = 0

    private var canBoostSpeedLimit = false

    private enum class Mode {
        Factor, Fast, Setback
    }

    private enum class Types {
        Up, Down, Preserve, LimitPreserve, Bounded, Conceal, Limit, LimitJitter
    }

    private enum class PhaseType {
        None, Semi, Full
    }

    private enum class LimitMode {
        Off, Speed, Tick, Both
    }

    init {
        addSettings(
            mode, phaseType, type,
            factor, reduction,
            antiKick, invalid, old, fastCollision, betterResponse,
            limitMode, rotation, instantPhase,
            airStrict, conceal, constantly, strictPhase, test
        )
    }

    override fun getHudInfo(): String = mode.fixedValue.toString()

    private fun clearAll() {
        canClip = false
        isGoingUp = false
        shouldConceal = false

        tickCounter = 0
        limitTickCounter = 0
        constantTickCounter = 0

        teleportId = 0
        ticksInAir = 0
        sentCount = 0
        teleportMap.clear()
        playerPackets.clear()
    }

    override fun onEnable() {
    }

    override fun onDisable() {
        if (fullNullCheck()) return
        clearAll()
        Globals.mc.player.noClip = false
    }

    private fun getBypassVector(type: Types, position: Vec3d): Vec3d {
        var spoofX = position.x
        var spoofY = position.y
        var spoofZ = position.z

        when (type) {
            Types.Down -> spoofY -= 1337.69
            Types.Up -> spoofY += 1337.69
            Types.Bounded -> spoofY = (if (spoofY < 127.5) 255 else 0) - position.y
            Types.Conceal -> {
                spoofX += RandomUtils.nextInt(-100000, 100000)
                spoofY += 2.0
                spoofZ += RandomUtils.nextInt(-100000, 100000)
            }
            Types.Limit -> {
                spoofX += RandomUtils.nextDouble(-50.0, 50.0)
                spoofY += if (RandomUtils.random.nextBoolean()) RandomUtils.nextDouble(-80.0, -50.0) else RandomUtils.nextDouble(50.0, 80.0)
                spoofZ += RandomUtils.nextDouble(-50.0, 50.0)
            }
            Types.LimitJitter -> {
                spoofX += RandomUtils.nextDouble(-10.0, 10.0)
                spoofY += if (RandomUtils.random.nextBoolean()) RandomUtils.nextDouble(-100.0, -80.0) else RandomUtils.nextDouble(80.0, 100.0)
                spoofZ += RandomUtils.nextDouble(-10.0, 10.0)
            }
            Types.Preserve -> {
                spoofX += RandomUtils.random.nextInt(100000)
                spoofZ += RandomUtils.random.nextInt(100000)
            }
            Types.LimitPreserve -> {
                spoofX += RandomUtils.nextDouble(10.0, 60.0)
                spoofY += if (RandomUtils.random.nextBoolean()) RandomUtils.nextDouble(-75.0, -55.0) else RandomUtils.nextDouble(60.0, 75.0)
                spoofZ += RandomUtils.nextDouble(-55.0, -18.0)
            }
        }

        return Vec3d(spoofX, spoofY, spoofZ)
    }

    private fun concealVector(position: Vec3d): Vec3d {
        val spoofX = position.x
        var spoofY = position.y
        val spoofZ = position.z

        spoofY = if (spoofY > 127.5) RandomUtils.nextDouble(-295.0, -278.0) else RandomUtils.nextDouble(278.0, 295.0)

        return Vec3d(spoofX, spoofY, spoofZ)
    }

    private fun sendPlayerPackets(x: Double, y: Double, z: Double, type: Types, canTeleport: Boolean) {
        val position = Globals.mc.player.positionVector.add(x, y, z)
        val outOfBoundsPacket = getBypassVector(type, position)

        if (invalid.value) {
            if (rotation.value) {
                sendPackets(CPacketPlayer.PositionRotation(position.x, position.y, position.z, Globals.mc.player.rotationYaw, Globals.mc.player.rotationPitch, false))
            } else {
                sendPackets(CPacketPlayer.Position(position.x, position.y, position.z, false))
            }

            if (resetTicks(2)) {
                if (conceal.value && shouldConceal) {
                    val concealVector = concealVector(position)
                    sendPackets(CPacketPlayer.Position(concealVector.x, concealVector.y, concealVector.z, Globals.mc.player.onGround))
                    shouldConceal = false
                }
                sendPackets(CPacketPlayer.Position(outOfBoundsPacket.x, outOfBoundsPacket.y, outOfBoundsPacket.z, Globals.mc.player.onGround))
            }
        } else {
            if (rotation.value) {
                sendPackets(CPacketPlayer.PositionRotation(position.x, position.y, position.z, Globals.mc.player.rotationYaw, Globals.mc.player.rotationPitch, Globals.mc.player.onGround))
            } else {
                sendPackets(CPacketPlayer.Position(position.x, position.y, position.z, Globals.mc.player.onGround))
            }

            if (conceal.value && shouldConceal && resetTicks(2)) {
                val concealVector = concealVector(position)

                if (rotation.value) {
                    sendPackets(CPacketPlayer.PositionRotation(concealVector.x, concealVector.y, concealVector.z, Globals.mc.player.rotationYaw, Globals.mc.player.rotationPitch, Globals.mc.player.onGround))
                    sendPackets(CPacketPlayer.PositionRotation(outOfBoundsPacket.x, outOfBoundsPacket.y, outOfBoundsPacket.z, Globals.mc.player.rotationYaw, Globals.mc.player.rotationPitch, Globals.mc.player.onGround))
                } else {
                    sendPackets(CPacketPlayer.Position(concealVector.x, concealVector.y, concealVector.z, Globals.mc.player.onGround))
                    sendPackets(CPacketPlayer.Position(outOfBoundsPacket.x, outOfBoundsPacket.y, outOfBoundsPacket.z, Globals.mc.player.onGround))
                }

                shouldConceal = false
            } else {

                if (rotation.value) {
                    sendPackets(CPacketPlayer.PositionRotation(outOfBoundsPacket.x, outOfBoundsPacket.y, outOfBoundsPacket.z, Globals.mc.player.rotationYaw, Globals.mc.player.rotationPitch, Globals.mc.player.onGround))
                } else {
                    sendPackets(CPacketPlayer.Position(outOfBoundsPacket.x, outOfBoundsPacket.y, outOfBoundsPacket.z, Globals.mc.player.onGround))
                }

                sendPackets(CPacketPlayer.Position(outOfBoundsPacket.x, outOfBoundsPacket.y, outOfBoundsPacket.z, Globals.mc.player.onGround))
            }
        }

        if (canTeleport) {
            Globals.mc.player.connection.sendPacket(CPacketConfirmTeleport(++teleportId))
            teleportMap[teleportId] = IDTime(position, System.currentTimeMillis())
        }

    }

    private fun sendPackets(packet: CPacketPlayer) {
        playerPackets.add(packet)
        Globals.mc.player.connection.sendPacket(packet)
    }

    private fun resetTicks(ticks: Int): Boolean {
        if (tickCounter++ >= ticks) {
            tickCounter = 0
            return true
        }
        return false
    }

    private fun resetLimitTicks(ticks: Int): Boolean {
        if (limitTickCounter++ >= ticks) {
            limitTickCounter = 0
            return true
        }
        return false
    }

    private fun resetConstantTicks(ticks: Int): Boolean {
        if (constantTickCounter++ >= ticks) {
            constantTickCounter = 0
            return true
        }
        return false
    }

    private fun doClip(event: MoveEvent) {
        if (mode.value != Mode.Setback && teleportId == 0) return

        event.x = Globals.mc.player.motionX
        event.y = Globals.mc.player.motionY
        event.z = Globals.mc.player.motionZ

        if (phaseType.value != PhaseType.None && (phaseType.value == PhaseType.Semi || checkBoundingBox() || instantPhase.value && Globals.mc.player.movementInput.sneak && Globals.mc.player.isSneaking)) {
            Globals.mc.player.noClip = true
        }

    }

    @Listener
    private fun onWorldUnload(event: WorldEvent.Unload) {
        clearAll()
    }

    @Listener
    private fun onWorldClientInit(event: WorldClientInitEvent) {
        clearAll()
    }

    @Listener
    private fun onTicking(event: TickEvent) {
        if (fullNullCheck()) return

        synchronized(teleportMap) {
            teleportMap.entries.removeIf { System.currentTimeMillis() - it.value.timer > TimeUnit.SECONDS.toMillis(30L) }
        }

    }

    @Listener
    private fun onPacketSent(event: PacketEvent.Send) {
        if (event.stage != EventStageable.EventStage.PRE) return

        if (event.packet is CPacketPlayer) {
            if (playerPackets.contains(event.packet)) {
                playerPackets.remove(event.packet)
                sentCount++
                return
            }
            event.cancel()
        }
    }

    @Listener
    private fun onPacketReceive(event: PacketEvent.Receive) {
        if (event.stage != EventStageable.EventStage.PRE || fullNullCheck()) return

        if (event.packet is SPacketPlayerPosLook) {

            if (Globals.mc.player.isAlive && Globals.mc.world.isBlockLoaded(BlockPos(Globals.mc.player.posX, Globals.mc.player.posY, Globals.mc.player.posZ), false) && Globals.mc.currentScreen !is GuiDownloadTerrain) {
                val sentPosition = teleportMap.remove(event.packet.teleportId)
                if ((!old.value || fastCollision.value && !isGoingUp && checkBoundingBox()) && mode.value != Mode.Setback && sentPosition != null && sentPosition.vector.x == event.packet.x && sentPosition.vector.y == event.packet.y && sentPosition.vector.z == event.packet.z) {
                    if (betterResponse.value) doBetterResponse(event)
                    event.cancel()
                    return
                } else if (conceal.value && mode.value != Mode.Setback && sentPosition != null && (sentPosition.vector.x != event.packet.x || sentPosition.vector.y != event.packet.y || sentPosition.vector.z != event.packet.z)) {
                    shouldConceal = true
                    // sendConcealPackets()
                } else {
                    if (betterResponse.value) doBetterResponse(event)
                    teleportMap.remove(event.packet.teleportId)
                }
            }

            event.packet.rotationYaw = Globals.mc.player.rotationYaw
            event.packet.rotationPitch = Globals.mc.player.rotationPitch

            teleportId = event.packet.teleportId
        }

        if (event.packet is SPacketCloseWindow) event.cancel()
    }

    private fun getLimitedHorizontalSpeed(): Double {
        return when (limitMode.value) {
            LimitMode.Tick -> {
                0.1899
            }
            LimitMode.Speed -> {
                if (!canBoostSpeedLimit) {
                    if (resetLimitTicks(7)) canBoostSpeedLimit = true
                    // ChatManager.sendMessage("First")
                    0.253
                    // 0.242
                } else {
                    if (resetLimitTicks(7)) canBoostSpeedLimit = false
                    // ChatManager.sendMessage("Second")
                    0.198
                    // 0.2187 No Average 17.58 First
                    // 0.2275 Average 17.58 First
                }
            }
            LimitMode.Both -> {
                if (!canBoostSpeedLimit) {
                    if (resetLimitTicks(1)) canBoostSpeedLimit = true
                    0.256
                } else {
                    if (resetLimitTicks(1)) canBoostSpeedLimit = false
                    0.1899
                }
            }
            else -> {
                0.26
            }
        }
    }


    private fun doPhase(event: MotionUpdateEvent) {
        if (event.stage == EventStageable.EventStage.POST) return

        Globals.mc.player.setVelocity(0.0, 0.0, 0.0)

//        if (sentCount > 5) {
//            sentCount = 0
//            return
//        }

//        ChatManager.sendMessage("inair = $ticksInAir")
//        ChatManager.sendMessage("counter = $sentCount")

        if (mode.value != Mode.Setback && teleportId == 0) {
            if (resetTicks(4)) {
                sendPlayerPackets(0.0, 0.0, 0.0, type.value, false)
            }
            return
        }

        val checkCollidingBox = checkBoundingBox()

        if (checkCollidingBox) {
            ticksInAir = 0
        } else if (MovementUtils.isAllMoveInputKeyDown()) {
            ticksInAir++
        }

        if (antiKick.value && airStrict.value && ticksInAir > 45 && sentCount > 12) {
            if (conceal.value) shouldConceal = true
            if (resetTicks(1)) {
                sendPlayerPackets(0.0, 0.0, 0.0, type.value, false)
                ticksInAir = 0
                sentCount = 0
            }
            return
        }

        var verticalSpeed = if (Globals.mc.player.movementInput.jump && (checkCollidingBox || !MovementUtils.isMoving())) {
            if (antiKick.value && !checkCollidingBox) {
                if (resetTicks(if (mode.value == Mode.Setback) 10 else 20)) -0.032 else 0.062
            } else {
                0.062
            }
        } else if (Globals.mc.player.movementInput.sneak) {
            -0.062
        } else {
            if (checkCollidingBox) 0.0 else if (resetTicks(4)) if (antiKick.value) -0.04 else 0.0 else 0.0
        }

        if (phaseType.value == PhaseType.Full && checkCollidingBox && MovementUtils.isMoving() && verticalSpeed != 0.0) {
            verticalSpeed /= 2.5 + reduction.value
        }

        if (phaseType.value == PhaseType.Full && test.value && checkCollidingBox && MovementUtils.isMoving() && verticalSpeed != 0.0) {
            val yaw = MovementUtils.calcMoveYaw()
            addMotion { move(Globals.mc.player.positionVector.add(-sin(yaw) * 0.00000001, 0.0, Globals.mc.player.posZ + cos(yaw) * 0.00000001)) }
        }

        // PlayerPacketManager.addPacket(this, PlayerPacketManager.PlayerPacket(rotation = Vec2f(MovementUtils.calcMoveYaw().toDegree().toFloat(), Globals.mc.player.rotationPitch)))
        val selectionType = if (strictPhase.value && checkCollidingBox) Types.LimitPreserve else type.value

        var i = 1.0
        var lastSentConstant = false

        while (i <= if (mode.value == Mode.Factor) factor.value else 1.0) {
            if (MovementUtils.isKeyDown()) {
                MovementUtils.setSpeed((if (phaseType.value == PhaseType.Full && checkCollidingBox) 0.031 else getLimitedHorizontalSpeed()) * i)
                isGoingUp = false
            }
            if (verticalSpeed != 0.0) {
                isGoingUp = true
                Globals.mc.player.motionY = verticalSpeed * i
            }

            sendPlayerPackets(Globals.mc.player.motionX, Globals.mc.player.motionY, Globals.mc.player.motionZ, selectionType, mode.value != Mode.Setback)

            if (constantly.value) {
                if (!lastSentConstant) {
                    if (resetConstantTicks(3)) {
                        lastSentConstant = true
                        sendPlayerPackets(Globals.mc.player.motionX, Globals.mc.player.motionY, Globals.mc.player.motionZ, selectionType, mode.value != Mode.Setback)
                    }
                } else {
                    if (resetConstantTicks(9)) {
                        lastSentConstant = false
                        sendPlayerPackets(Globals.mc.player.motionX, Globals.mc.player.motionY, Globals.mc.player.motionZ, selectionType, mode.value != Mode.Setback)
                    }
                }
            }

            i += 0.1
        }

    }

    private fun checkIsServerSideSuff() = EntityUtil.isInBlockServerSide(Globals.mc.player)

    private fun checkBoundingBox() =
        Globals.mc.world.getCollisionBoxes(Globals.mc.player, Globals.mc.player.entityBoundingBox.expand(-0.0625, -0.0625, -0.0625)).isNotEmpty()

    @Listener
    private fun onMove(event: MoveEvent) {
        doClip(event)
    }

    @Listener
    private fun onMotionUpdate(event: MotionUpdateEvent) {
        if (fullNullCheck()) return
        doPhase(event)
    }

    @Listener
    private fun onSetOpaqueCube(event: SetOpaqueCubeEvent) {
        event.cancel()
    }

    @Listener
    private fun onRenderOverlay(event: RenderOverlayEvent) {
        event.cancel()
    }

    @Listener
    private fun onPlayerCollision(event: PlayerApplyCollisionEvent) {
        event.cancel()
    }

    @Listener
    private fun onIsEntityInsideOpaqueBlock(event: IsEntityInsideOpaqueBlockEvent) {
        event.cancel()
    }

    /*
    @Listener
    private fun onCollideBlock(event: CollisionBoxEvent) {
        if (PlayerUtil.isInsideBlock() && Globals.mc.player.collidedHorizontally && event.boundingBox != null && event.boundingBox.maxY > Globals.mc.player.entityBoundingBox.minY) {
            event.setBb(Block.NULL_AABB)
        }
    }
 */

    private fun doBetterResponse(event: PacketEvent.Receive) {
        if (event.packet !is SPacketPlayerPosLook) return

        var x = event.packet.x
        var y = event.packet.y
        var z = event.packet.z
        var yaw = event.packet.yaw
        var pitch = event.packet.pitch
        if (event.packet.flags.contains(SPacketPlayerPosLook.EnumFlags.X)) {
            x += Globals.mc.player.posX
        }
        if (event.packet.flags.contains(SPacketPlayerPosLook.EnumFlags.Y)) {
            y += Globals.mc.player.posY
        }
        if (event.packet.flags.contains(SPacketPlayerPosLook.EnumFlags.Z)) {
            z += Globals.mc.player.posZ
        }
        if (event.packet.flags.contains(SPacketPlayerPosLook.EnumFlags.X_ROT)) {
            pitch += Globals.mc.player.rotationPitch
        }
        if (event.packet.flags.contains(SPacketPlayerPosLook.EnumFlags.Y_ROT)) {
            yaw += Globals.mc.player.rotationYaw
        }
        Globals.mc.connection?.sendPacket(CPacketPlayer.PositionRotation(x, Globals.mc.player.entityBoundingBox.minY, z, yaw, pitch, false))
    }

    class IDTime(val vector: Vec3d, val timer: Long)

}