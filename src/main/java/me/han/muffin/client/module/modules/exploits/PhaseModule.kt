package me.han.muffin.client.module.modules.exploits

import me.han.muffin.client.core.Globals
import me.han.muffin.client.event.EventStageable
import me.han.muffin.client.event.events.client.MotionUpdateEvent
import me.han.muffin.client.event.events.client.MoveEvent
import me.han.muffin.client.event.events.entity.player.PlayerApplyCollisionEvent
import me.han.muffin.client.event.events.render.IsEntityInsideOpaqueBlockEvent
import me.han.muffin.client.event.events.render.overlay.RenderOverlayEvent
import me.han.muffin.client.event.events.world.CollisionBoxEvent
import me.han.muffin.client.event.events.world.SetOpaqueCubeEvent
import me.han.muffin.client.module.Module
import me.han.muffin.client.module.modules.movement.BoatFlyModule
import me.han.muffin.client.utils.timer.Timer
import me.han.muffin.client.value.EnumValue
import me.han.muffin.client.value.NumberValue
import net.minecraft.block.Block
import net.minecraft.entity.item.EntityBoat
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener

internal object PhaseModule: Module("Phase", Category.EXPLOITS, "Allows you to glitch through blocks.") {
    val mode = EnumValue(Mode.Boat, "Mode")
    private val speed = NumberValue(10.0, 1.0, 20.0, 0.1, "Speed")

    private val timer = Timer()

    enum class Mode {
        Boat, Sand//, Climb, Door, Normal
    }

    init {
        addSettings(mode, speed)
    }

    override fun onEnable() {
    }

    override fun onDisable() {
        Globals.mc.player.noClip = false
    }

    override fun getHudInfo(): String? = mode.fixedValue

    @Listener
    private fun onMotionUpdate(event: MotionUpdateEvent) {
        if (event.stage != EventStageable.EventStage.PRE) return

        if (fullNullCheck()) return

        when (mode.value) {
            Mode.Boat -> {
                if (Globals.mc.player?.ridingEntity is EntityBoat) {
                    Globals.mc.player.noClip = true
                    Globals.mc.player.motionY = 0.0
                    Globals.mc.player.onGround = false
                    Globals.mc.player.capabilities.isFlying = false
                }
            }
            Mode.Sand -> {

            }
            /*
            Mode.Climb -> {
                Globals.mc.player.motionY = 0.0
                if (Globals.mc.inGameHasFocus) {
                    if (Globals.mc.player.movementInput.jump) {
                        Globals.mc.player.motionY += 4.24399158E-315
                    }
                    if (Globals.mc.player.movementInput.sneak) {
                        Globals.mc.player.motionY -= 4.24399158E-315
                    }
                }
                Globals.mc.player.noClip = true
            }
            Mode.Normal -> {
                if (!Globals.mc.player.collidedHorizontally || !timer.passed(200.0)) return
                Globals.mc.player.connection.sendPacket(CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY + 1.273197475E-314, Globals.mc.player.posZ, true))
                Globals.mc.player.connection.sendPacket(CPacketPlayer.Position(Globals.mc.player.posX + d * 0.0, Globals.mc.player.posY, Globals.mc.player.posZ + d2 * 0.0, true))
                Globals.mc.player.connection.sendPacket(CPacketPlayer.Position(Globals.mc.player.posX, Globals.mc.player.posY,Globals.mc.player.posZ, true))
                timer.reset()
            }
             */
        }

    }

    @Listener
    private fun onMoving(event: MoveEvent) {
        if (fullNullCheck()) return

        Globals.mc.player?.ridingEntity?.let {
            if (mode.value == Mode.Boat && BoatFlyModule.isDisabled) {
                if (it !is EntityBoat) return
                it.entityBoundingBox = it.entityBoundingBox.offset(event.x * speed.value, event.y, event.z * speed.value)
            }
        }

        if (mode.value == Mode.Sand) {
            Globals.mc.player.entityBoundingBox = Globals.mc.player.entityBoundingBox.offset(event.x * speed.value, event.y, event.z * speed.value)
        }

    }


    @Listener
    private fun onCollision(event: CollisionBoxEvent) {
        if (fullNullCheck()) return

        when (mode.value) {
            Mode.Sand -> {
                if (event.boundingBox == null || event.boundingBox!!.maxY <= Globals.mc.player.entityBoundingBox.minY || !Globals.mc.player.isSneaking) return
                event.boundingBox = Block.NULL_AABB
            }
            /*
            Mode.Climb -> {
                event.boundingBox = Block.NULL_AABB
                Globals.mc.player.noClip = true
            }
            Mode.Door -> {
                if (Globals.mc.player.collidedHorizontally) event.boundingBox = Block.NULL_AABB
                if (!Globals.mc.player.movementInput.sneak && (!Globals.mc.player.movementInput.jump || event.pos.y <= Globals.mc.player.posY)) return
            }
             */
        }
    }

    @Listener
    private fun onSetOpaqueCube(event: SetOpaqueCubeEvent) {
        event.cancel()
    }

    @Listener
    private fun onRenderOverlay(event: RenderOverlayEvent) {
        event.cancel()
    }

    @Listener
    private fun onPlayerCollision(event: PlayerApplyCollisionEvent) {
        event.cancel()
    }

    @Listener
    private fun onIsEntityInsideOpaqueBlock(event: IsEntityInsideOpaqueBlockEvent) {
        event.cancel()
    }

}