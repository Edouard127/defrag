package com.lambda.client.module.modules.extra

import com.lambda.client.event.events.ConnectionEvent
import com.lambda.client.event.events.PacketEvent
import com.lambda.client.event.events.RenderWorldEvent
import com.lambda.client.module.Category
import com.lambda.client.module.Module
import com.lambda.client.module.modules.extra.coordExploit.TrackedPlayer
import com.lambda.client.util.color.ColorHolder
import com.lambda.client.util.graphics.ESPRenderer
import com.lambda.client.util.text.MessageSendHelper
import com.lambda.client.util.threads.safeListener
import com.lambda.event.listener.listener
import com.lambda.client.module.modules.extra.coordExploit.BlockCheckTask
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock
import net.minecraft.network.play.server.SPacketBlockChange
import net.minecraft.util.EnumFacing
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.gameevent.TickEvent

object CoordExploit : Module(
    name = "CoordExploit",
    description = "Finds players by checking loaded chunks",
    category = Category.MISC
) {

    private val mode by setting("SearchMode", SearchMode.BATTLESHIP)
    private val locationChunksToCheck by setting("LocationChunksToCheck", 8, 2..50, 1)
    private val initSearchMode by setting("InitSearchMode", StartMode.SPIRAL)
    private val clownESP by setting("ClownESP", true)
    private val ppt by setting("PPT", 100, 1..10000, 1)
    private val maxPendingChunks by setting("MaxPendingChunks", 100, 50..100000, 50)
    private val maxPendingTime by setting("MaxPendingTime", 1000, 500..10000, 500)
    private val passiveSearchDelay by setting("PassiveSearchDelayms", 5000, 1000..10000, 10)


    private val trackedPlayers = ArrayList<TrackedPlayer>()
    private val queuedBlockChecks = ArrayList<BlockCheckTask>()
    private val waitingChecks = ArrayList<BlockCheckTask>()

    private val renderer = ESPRenderer()
    private var currentBlockToCheck = BlockPos(0, 0, 0)

    init {
        listener<TickEvent.ClientTickEvent> {

            var thisTickPackets = 0

            queuedBlockChecks.sortByDescending { it.importance }
            val iterator = queuedBlockChecks.iterator()

            waitingChecks.removeIf { it.sendTime < System.currentTimeMillis() - maxPendingTime }


            while (thisTickPackets < ppt && iterator.hasNext() && waitingChecks.size < maxPendingChunks) {
                val task = iterator.next()

                try {
                    currentBlockToCheck = task.blockPos
                    waitingChecks.add(BlockCheckTask(currentBlockToCheck))
                    sendClick(task)
                } catch (e: ConcurrentModificationException) {
                }
                thisTickPackets++
                iterator.remove()
            }

            if (initSearchMode == StartMode.HIGHWAYS) {

                if (queuedBlockChecks.size < 1000) {
                    doHighwaySearch()
                }
            }

            if (mode == SearchMode.BATTLESHIP) {
                for (tPlayer in trackedPlayers) {
                    findNewCenter(tPlayer)
                }
            }
        }

        safeListener<PacketEvent.Receive> {
            if (it.packet is SPacketBlockChange) {
                val packet = it.packet

                for (queuedBlockCheck in queuedBlockChecks) {
                    if (queuedBlockCheck.blockPos == packet.blockPosition) {
                        processReceiving(packet)
                    }
                }


            }
        }

        safeListener<RenderWorldEvent> {

            if (clownESP) {
                renderer.aTracer = 255
                renderer.thickness = 2.0F

                val rgb = ColorHolder()

                for (trackedPlayer in trackedPlayers) {
                    renderer.add(BlockPos(trackedPlayer.playerChunk.x, 150, trackedPlayer.playerChunk.z), rgb)
                }

                renderer.render(true)
            }
        }

        safeListener<ConnectionEvent> {
            disable()
        }
    }

    private fun processReceiving(packet: SPacketBlockChange) {
        MessageSendHelper.sendChatMessage("$packet")
    }

    private fun sendClick(task: BlockCheckTask) {
        mc.connection?.sendPacket(CPacketPlayerTryUseItemOnBlock(task.blockPos, EnumFacing.UP, EnumHand.MAIN_HAND, 0f, 0f, 0f))
    }


    private fun findNewCenter(player: TrackedPlayer) {

        for (i in 1..locationChunksToCheck) {
            queuedBlockChecks.add(BlockCheckTask(BlockPos((player.playerChunk.x + i) * 16, 0, player.playerChunk.z * 16), importance = 20))
            queuedBlockChecks.add(BlockCheckTask(BlockPos((player.playerChunk.x - i) * 16, 0, player.playerChunk.z * 16), importance = 20))
            queuedBlockChecks.add(BlockCheckTask(BlockPos(player.playerChunk.x * 16, 0, (player.playerChunk.z + i) * 16), importance = 20))
            queuedBlockChecks.add(BlockCheckTask(BlockPos(player.playerChunk.x * 16, 0, (player.playerChunk.z - i) * 16), importance = 20))
        }
    }

    private fun doHighwaySearch() {
        for (i in 1..1875000) {
            queuedBlockChecks.add(BlockCheckTask(BlockPos(i * 16, 0, 0), 5))
            queuedBlockChecks.add(BlockCheckTask(BlockPos(0, 0, i * 16), 5))
            queuedBlockChecks.add(BlockCheckTask(BlockPos(-(i * 16), 0, 0), 5))
            queuedBlockChecks.add(BlockCheckTask(BlockPos(0, 0, -(i * 16)), 5))
        }
    }

    enum class SearchMode {
        BATTLESHIP
    }

    enum class StartMode {
        HIGHWAYS,
        SPIRAL
    }
}